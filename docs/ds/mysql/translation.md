# Mysql事务

## 一、简介
> 事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)
  一个完整的业务会执行多条SQL语句，要么全部执行成功，要么全部执行失败。

## 二、事物四大特性

- **原子性**

  事务是最小单元，不可再分，要么全部执行成功，要么全部失败回滚
- **一致性**

  一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。**不一致性**包含三点：脏读，不可重复读，幻读
- **隔离性**

  隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离
- **持久性**

  对数据的修改是永久性的

## 三、事物隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|-----|-----|-----|-----|
| 读未提交(Read uncommitted) | 可能 | 可能 | 可能 |
| 读已提交(Read committed) | 不可能 | 可能 | 可能 |
| 可重复读(Repeatable read) | 不可能 | 不可能 | 可能 |
| 串行化(Serializable) | 不可能 | 不可能 | 不可能 |

从上往下，隔离强度逐渐增强，性能逐渐变差。其中，**可重复读**是 MySQL 的默认级别。

- **读未提交：read uncommitted**

> 
- 事物A和事物B, 事物A未提交的数据, 事物B可以读取到, 这就会导致脏读.
- 脏读: 脏读就是读到了别的事务回滚前的脏数据. 比如事务B执行过程中修改了数据X, 在未提交前，事务A读取了X, 而事务B却回滚了, 这样事务A就形成了脏读.
- 这种隔离级别最低, 这种级别一般是在理论上存在, 数据库隔离级别一般都高于该级别.

- **读已提交Read committed**

> - 事物A和事物B, 事物A提交的数据，事物B才能读取到.
- 这种级别可以避免“脏数据”, 但会导致“不可重复读取”.
- 不可重复读: 事务A首先读取了一条数据, 然后执行逻辑的时候，事务B将这条数据改变了, 然后事务A再次读取的时候, 发现数据不匹配了, 就是所谓的不可重复读了.
- Oracle默认隔离级别.

- **可重复读Repeatable read**

> - 事务A和事务B，事务A提交之后的数据, 事务B读取不到, 事务B是可重复读取数据.
- 这种隔离级别可以避免“不可重复读取”, 但是会导致“幻像读”.
- 幻读: 事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读.
- MySQL默认级别.

- **串行化Serializable**

> - 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
- 这种隔离级别很少使用，吞吐量太低，用户体验差
- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发

不可重复读和幻读比较：
两者有些相似，但是前者针对的是update或delete，后者针对的insert。

## 四、事务提交和回滚原理
- 为了保证数据的持久性，数据库在执行SQL操作数据之前会先记录redo log和undo log
- redo log是重做日志，是用来恢复数据的，用于保障已提交事务的持久化特性
- undo log是回滚日志，记录事务修改之前版本的数据信息，用来回滚数据的用于保障 未提交事务的原子性
- redo/undo log都是写先写到日志缓冲区，再通过缓冲区写到磁盘日志文件中进行持久化保存
- undo日志还有一个用途就是用来控制数据的多版本（MVCC）

** redo log *

** undo log **


## 五、如何解决幻读

### 5.1 当前读和快照读

#### InnoDB下的当前读和快照读

- **当前读：**像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
- **快照读：**像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

**MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现**

### 5.2 多版本并发控制MVCC (MultiVersion Concurrency Control)
MVCC 和 undo log 有关，undo log 可以分为：
- insert undo log: insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃
- upate undo log: 事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要;只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除
![](/static/img/mysql/versionLinked.png)

#### Mysql 数据库中每行记录会有两列隐藏
- trx_id ，当修改操作的事务提交了，会将事务 id 赋值给当前行记录中的 trx_id
- roll_pointer 指向 undo log 中指针

> 事务 id 生成不是在 begin 之后直接生成，而是执行了 sql 之后生成。比如当我们执行了 INSERT、UPDATE、DELETE 之后才会生成。事务 id 是递增并且唯一的。
对数据库中的某行的修改，都会将旧数据放入到 undo log 中，随着更新的版本越来越多，roll_pointer 链接形成了版本链，这个版本链就是用于 MVCC 使用的。

#### 当没有加锁查询数据的时候，就可以从版本链上判断当前事务是否可以查看某个数据：
- 如果 trx_id 和当前事务的 id 一致，说明是当前事务修改的，该版本数据可以别查看。
- 如果 trx_id 和当前事务 id 不一致，并且 trx_id 对应的事务没有提交，不能看到
- 如果 trx_id 小于当前事务 id ，那么该版本数据也可以被访问到。
- 如果 trx_id 大于当前事务 id，那么版本不能被看到。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

对于**重复读**来说，只有在事务中第一次读取数据时select，才会生成事务 id。

对于**读已提交**来说，在事务中每次读取数据select，都会生成一个事务 id。
